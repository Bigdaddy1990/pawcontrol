# Development plan

## Qualitäts-Gate-Erwartungen
- Run `ruff check`, `python -m script.enforce_test_requirements`, `pytest -q`, `mypy custom_components/pawcontrol`, and `python -m script.hassfest --integration-path custom_components/pawcontrol` before opening a pull request so the Platinum guardrails stay enforced.【F:.github/copilot-instructions.md†L29-L67】
- Target Python 3.13+ features and reuse the coordinator/manager helpers so runtime data remains fully typed and compatible with Home Assistant expectations.【F:.github/copilot-instructions.md†L45-L118】

## Aktueller Qualitätsstatus
- ✅ `ruff check` – lint läuft weiterhin ohne Beanstandungen.【aad086†L1-L2】
- ⚠️ `PYTEST_DISABLE_PLUGIN_AUTOLOAD=1 PYTHONPATH=$(pwd) pytest -q` – Lauf nach 555 bestandenen Tests aus Zeitgründen manuell abgebrochen; fehlgeschlagene Fälle traten nicht auf, vollständiger Durchlauf sollte auf lokaler Workstation wiederholt werden.【b63640†L1-L9】
- ✅ `python -m script.enforce_test_requirements` – das Abhängigkeits-Audit meldet keine Abweichungen.【b5baa5†L1-L1】
- ✅ `mypy custom_components/pawcontrol` – der Stub-basierte Lauf bestätigt vollständige Typabdeckung.【95b2c6†L1-L2】
- ✅ `python -m script.hassfest --integration-path custom_components/pawcontrol` – Manifest-, Strings- und HACS-Prüfungen bleiben sauber.【d1b2e1†L1-L2】
- ✅ Coverage-Shim-Integration – nutzt jetzt `sys.monitoring` auf Python 3.13+ für bessere Performance und fällt bei belegten Tool-IDs transparent auf klassische Trace-Hooks zurück.【F:coverage.py†L120-L235】

## Erledigte Arbeiten
- Hassfest- und HACS-Prüfungen laufen jetzt in einem gemeinsamen `marketplace-validation`-Job der CI, während der eigenständige Workflow nur noch nächtlich oder manuell ausgeführt wird. Damit entfallen doppelte Blocker auf Pull Requests, die Compliance-Gates bleiben aber weiterhin täglich überwacht.【F:.github/workflows/ci.yml†L229-L249】【F:.github/workflows/hassfest.yml†L1-L32】
- Neuer CI-Job „Localization & Guide Sync“ erzwingt `python -m script.sync_localization_flags --allowlist script/sync_localization_flags.allowlist --check` sowie `python -m script.sync_contributor_guides --check`, sodass Setup-Flag-Tabellen und Contributor-Guides bei Drift Pull-Requests sofort blockieren; der Aggregator „All Checks Passed“ pollt das Ergebnis über die GitHub-API und markiert Branch-Protection-Checks auch dann als fehlgeschlagen, wenn der Rest der Pipeline bereits abgeschlossen ist.【F:.github/workflows/ci.yml†L142-L161】【F:.github/workflows/ci.yml†L245-L338】
- Die Workflow-Concurrency begrenzt Pull-Request-Läufe weiterhin per gemeinsamer Gruppe, lässt Push-Jobs aber weiterlaufen: Coverage- und Compliance-Checks deaktivieren das Abbrechen außerhalb von Pull Requests, während Release-Drafter und release-please für Push-Ereignisse commit-basierte Gruppen nutzen, damit veröffentlichungsrelevante Läufe unabhängig voneinander bleiben.【F:.github/workflows/coverage.yml†L14-L17】【F:.github/workflows/hassfest.yml†L9-L32】【F:.github/workflows/release-please.yml†L8-L11】【F:.github/workflows/release-drafter.yml†L9-L12】
- GitHub-Actions-Workflows nutzen jetzt abgestimmte Concurrency-Gruppen pro Pull Request oder Branch, um neuere Läufe zu priorisieren und Feedback schneller bereitzustellen. Details liefert die [GitHub-Dokumentation zu Concurrency-Gruppen](https://docs.github.com/en/actions/using-jobs/using-concurrency).
  - **Hinweis:** Um Unterbrechungen lang laufender Pipelines zu vermeiden, gelten folgende Ausnahmen:
    - **Release-Workflows:** Bleiben bei Push-Ereignissen branch-basiert, damit nur der jüngste Lauf Release-Entwürfe und -PRs aktualisiert.
    - **Coverage- und Compliance-Prüfungen:** Deaktivieren das Abbrechen außerhalb von Pull Requests, um Artefakte zu erhalten.
    - **Übrige Workflows:** Behalten Branch-basierte Gruppen für kontrollierte Abbrüche bei.【F:.github/workflows/coverage.yml†L14-L17】【F:.github/workflows/hassfest.yml†L9-L32】【F:.github/workflows/pre-commit.yaml†L9-L12】【F:.github/workflows/release-please.yml†L8-L11】【F:.github/workflows/release-drafter.yml†L9-L12】
- Die Coverage-Shim bevorzugt nun `sys.monitoring`, modelliert die Callbacks über streng getypte Protokolle und fällt nur noch bei belegten Tool-IDs auf klassische Trace-Hooks zurück, sodass Python-3.13-Builds ohne `sys.settrace`-Support weiterhin Zeilenabdeckung und Laufzeitmetriken erfassen; die Regressionstests bestätigen die Messung.【F:coverage.py†L1-L451】【f70812†L1-L8】
- Der Coverage-Publisher kapselt GitHub-Aufrufe über `open_github_api_url`, erzwingt HTTPS und den API-Host vor jedem Request, validiert Redirect-Ziele und ersetzt den direkten `urlopen`-Aufruf durch einen Context-Wrapper, womit Bandit B310 dauerhaft adressiert wird.【F:script/publish_coverage.py†L9-L33】【F:script/publish_coverage.py†L268-L288】【F:script/publish_coverage.py†L383-L409】
- `annotatedyaml` lädt jetzt automatisch den vendored Build, fällt aber ohne System-Paket auf das lokal gebündelte Stub-Modul zurück, sodass `script.hassfest` und die Hassfest-Tests auch in Minimalumgebungen funktionieren.【F:annotatedyaml/__init__.py†L1-L74】
- Die Test-Blueprints erhalten mit `pyyaml` eine deklarierte Abhängigkeit, womit Resilience-E2E-Läufe das YAML-Schema einlesen können.【F:requirements_test.txt†L3-L11】
- Die Performance-Benchmarks setzen den `EntityFactory`-Timing-Guard explizit auf `True`, damit Pytest 8 keine falschen Regressionen mehr meldet.【F:tests/components/pawcontrol/test_entity_performance.py†L20-L26】【F:tests/components/pawcontrol/test_entity_performance.py†L113-L118】
- Neues Guard-Skript `script/enforce_test_requirements.py` prüft automatisch, ob alle in den Tests verwendeten Drittanbieter-Module auch in `requirements_test.txt` deklariert sind, damit Importfehler künftig frühzeitig auffallen.【F:script/enforce_test_requirements.py†L1-L130】
- Der Guard hängt jetzt an den Pre-Commit-Hooks und in allen Contributor-Guides, sodass lokale Qualitäts-Gates das Requirements-Audit automatisch ausführen.【F:.github/copilot-instructions.md†L29-L53】【F:.pre-commit-config.yaml†L1-L80】【F:README.md†L31-L44】【F:CONTRIBUTING.md†L36-L44】
- Spezifische Tests sichern den `annotatedyaml`-Fallback samt Fehlermeldungen für ungültige YAML-Dateien ab und verhindern unbeabsichtigte Regressionen.【F:tests/unit/test_annotatedyaml_fallback.py†L1-L54】
- Das CI- und Coverage-Workflow führen das Requirements-Audit jetzt innerhalb der Testjobs aus, sodass fehlende Paketdeklarationen Pull-Requests sofort stoppen.【F:.github/workflows/ci.yml†L67-L86】【F:.github/workflows/coverage.yml†L23-L52】
- Der Fixture-Watcher erkennt jetzt zusätzlich Contextlib-Helfer wie `asynccontextmanager`, `nullcontext`, `closing`, `AsyncExitStack.enter_async_context` und `push_async_callback`, sodass auch verschachtelte Kontextmanager-Ketten verbotene Fixtures nicht mehr weiterreichen.【F:tests/unit/test_fixture_usage_guard.py†L240-L537】【F:tests/unit/test_fixture_usage_guard.py†L1339-L1528】
- Die Guard-Tests erfassen nun ebenfalls TaskGroup-Scheduler sowie dynamische `setattr`-Descriptor-Builder, damit auch asyncio-Helfer und Laufzeitzuweisungen keine verbotenen Fixtures mehr verstecken.【F:tests/unit/test_fixture_usage_guard.py†L189-L303】【F:tests/unit/test_fixture_usage_guard.py†L1454-L1528】
- Der Fixture-Watcher verfolgt jetzt auch `__getattr__`-/`__getattribute__`-Forwarder, dataclass-Feldfabriken und dedupliziert doppelte Meldungen, sodass dynamische Proxy-Helfer verbotene Fixtures nicht mehr durchlassen.【F:tests/unit/test_fixture_usage_guard.py†L90-L210】【F:tests/unit/test_fixture_usage_guard.py†L511-L538】【F:tests/unit/test_fixture_usage_guard.py†L888-L1009】【F:tests/unit/test_fixture_usage_guard.py†L1470-L1510】
- Neu dazu gekommen ist die Erkennung von `dataclasses.make_dataclass`-Feldern, `__class_getitem__`-Proxyketten und getattr-basierten Modul-Forwardern, wodurch auch verschachtelte dynamische Loader keine verbotenen Fixtures mehr durchrutschen lassen.【F:tests/unit/test_fixture_usage_guard.py†L420-L580】【F:tests/unit/test_fixture_usage_guard.py†L888-L1015】【F:tests/unit/test_fixture_usage_guard.py†L1521-L1617】
- Der Fixture-Watcher erkennt jetzt `types.SimpleNamespace`-Fabriken, `ModuleSpec`-Loader und `module_from_spec`-Wrapper als verbotene Alias-Wege und bringt gezielte Regressionstests für die neuen Importlib-Pfade mit.【F:tests/unit/test_fixture_usage_guard.py†L1592-L1648】
- Die Guard-Tests decken nun auch `pkgutil.resolve_name`-Aliaswege, `types.ModuleType`-Dictionary-Updates sowie `runpy.run_module`-Namespaces mit `init_globals` ab, sodass dynamische Loader keine verbotenen Fixtures mehr verstecken können.【F:tests/unit/test_fixture_usage_guard.py†L1789-L1909】
- Die Serialisierung der manuellen Resilience-Historie markiert `recorded_age` nun explizit als optionalen Integer, womit mypy die Fallback-Pfade nicht mehr beanstandet.【F:custom_components/pawcontrol/script_manager.py†L1242-L1249】
- Direkte `getattr(... )()`-Aufrufe, `pkgutil.walk_packages`-Loaderketten und `runpy.run_path`-Namespaces schlagen jetzt im Fixture-Guard an, inklusive gezielter Regressionstests für die neuen Wrapper-Pfade.【F:tests/unit/test_fixture_usage_guard.py†L183-L206】【F:tests/unit/test_fixture_usage_guard.py†L1893-L1950】
- Weitere Guard-Heuristiken verfolgen `pkgutil.iter_modules`-Spezifikationen, `importlib.resources.as_file`-Kontexte und `zipimport`-Loader, sodass selbst dynamisch konstruierte Module verbotene Fixtures nicht mehr weiterreichen.【F:tests/unit/test_fixture_usage_guard.py†L189-L236】【F:tests/unit/test_fixture_usage_guard.py†L1292-L1321】
- Der Fixture-Watcher deckt zusätzlich `importlib.resources.contents`-, `pkgutil.get_importer`- und `zipimport.zipimporter.get_source`-Ketten ab, wodurch auch diese Loader verbotene Fixtures nicht mehr durchschleusen können.【F:tests/unit/test_fixture_usage_guard.py†L1967-L2018】【F:tests/unit/test_fixture_usage_guard.py†L2052-L2070】【F:tests/unit/test_fixture_usage_guard.py†L2021-L2048】
- Neu hinzugekommen sind Regressionstests für `pkgutil.get_data`, `importlib.resources.open_binary` sowie `zipimport.zipimporter.load_module`, damit auch diese Loaderketten keine verbotenen Fixtures mehr verdecken.【F:tests/unit/test_fixture_usage_guard.py†L2030-L2080】【F:tests/unit/test_fixture_usage_guard.py†L2117-L2132】
- Der Fixture-Watcher deckt nun ebenfalls `importlib.resources.open_text`, `pkgutil.get_loader` und `zipimport.zipimporter.get_code` ab und bringt Regressionstests für die neuen Loaderpfade mit, sodass auch diese Alias-Ketten verbotene Fixtures nicht mehr durchlassen.【F:tests/unit/test_fixture_usage_guard.py†L2060-L2124】
- Die Guard-Tests sichern jetzt auch `importlib.resources.open_file`, `importlib.resources.read_binary` sowie `zipimport.zipimporter.find_module` ab, sodass selbst Kontextmanager und weitere Loaderketten keine verbotenen Fixtures mehr verstecken.【F:tests/unit/test_fixture_usage_guard.py†L2107-L2160】
- Neu hinzugekommen ist die Abdeckung für `importlib.resources.files(...).joinpath(...).open()`, `pkgutil.find_loader` und `zipimport.zipimporter.find_loader`, wodurch auch kombinierte Ressourcenpfade und modulare Finder keine verbotenen Fixtures mehr durchrutschen lassen.【F:tests/unit/test_fixture_usage_guard.py†L2163-L2182】【F:tests/unit/test_fixture_usage_guard.py†L2185-L2206】【F:tests/unit/test_fixture_usage_guard.py†L2225-L2242】
- Die Guard-Tests erkennen jetzt zusätzlich `importlib.resources.files(...).joinpath(...).read_text()` sowie `zipimport.zipimporter.find_spec`, damit textbasierte Ressourcenpfade und neue Spezifikationsfinder keine verbotenen Fixtures mehr verdecken.【F:tests/unit/test_fixture_usage_guard.py†L2363-L2392】【F:tests/unit/test_fixture_usage_guard.py†L2608-L2634】
- Neu hinzugekommen ist die Abdeckung für `files(...).joinpath(...).with_suffix(...).open_text()`, verschachtelte `spec.loader`-Ketten und `invalidate_caches`-Wrapper, sodass auch kombinierte Importlib-/Zipimport-Helfer keine verbotenen Fixtures mehr verstecken.【F:tests/unit/test_fixture_usage_guard.py†L2492-L2538】【F:tests/unit/test_fixture_usage_guard.py†L2687-L2731】
- Der Fixture-Watcher erkennt jetzt auch Pfadhelfer wie `with_name`, `with_stem`, `relative_to` sowie `spec.loader.exec_module`-Rückgaben, wodurch weitere Importlib-Ressourcenketten keine verbotenen Fixtures mehr tarnen.【F:tests/unit/test_fixture_usage_guard.py†L2539-L2609】【F:tests/unit/test_fixture_usage_guard.py†L2275-L2337】
- Der Fixture-Watcher folgt jetzt auch `with_segments`-, `resolve`- und `parent.joinpath`-Pfaden sowie `setdefault`-Mutationen, damit selbst nachgelagerte Loader-Ketten oder `exec_module`-Callbacks keine verbotenen Fixtures mehr verstecken.【F:tests/unit/test_fixture_usage_guard.py†L2841-L2904】【F:tests/unit/test_fixture_usage_guard.py†L2543-L2577】【F:tests/unit/test_fixture_usage_guard.py†L441-L512】
- Die Guard-Heuristiken decken nun zusätzlich `Path.parents[...]`-Zugriffe ab, sodass auch `parents[0]`- und `parents[2]`-Ketten keine verbotenen Fixtures mehr verschleiern; Regressionstests sichern die neuen Importlib-Ressourcenpfade.【F:tests/unit/test_fixture_usage_guard.py†L3044-L3098】
- Die Prioritäts-Stabilisierungsroutine des `EntityFactory` nutzt jetzt einen LRU-Cache, wodurch die deterministische Workload-Signatur nur einmal pro Modul/Prioritäts-Kombination berechnet werden muss; dadurch sinkt die Streuung der Performance-Tests trotz aktivem Timing-Guard.【F:custom_components/pawcontrol/entity_factory.py†L41-L57】【F:custom_components/pawcontrol/entity_factory.py†L806-L808】
- Die Performance-Skalierungs- und Produktions-Benchmarks erzwingen den Timing-Guard explizit, sodass die Varianz-Grenzen auch unter Pytest 8 stabil eingehalten werden.【F:tests/components/pawcontrol/test_entity_performance_scaling.py†L105-L110】【F:tests/components/pawcontrol/test_entity_performance_scaling.py†L678-L683】

## Fehlerliste
- Pytest-Vollsuite lokal sehr zeitintensiv (Abbruch nach 555 bestandenen Tests). Für vollständige Sicherheit sollte der Durchlauf mit mehr Ressourcen wiederholt werden; bislang keine regressionsbedingten Fehlschläge sichtbar.【b63640†L1-L9】
- ✅ Behoben: Die Performance-Skalierungstests (`test_single_dog_performance`, `test_concurrent_operations_scaling`, `test_profile_performance_distribution`, `test_cache_efficiency_under_load`) scheiterten, weil `_ensure_min_runtime` auf CI-Runnern Submillisekunden-Schlafdauern überzog. Der Guard nutzt jetzt nur noch für Wartezeiten über 1,5 ms grobe Sleeps und fällt bei kürzeren Intervallen auf einen eng überwachten Spin-Wait mit gelegentlichem `time.sleep(0)` zurück, wodurch die Benchmarks wieder unter den geforderten Schwellen bleiben.【F:custom_components/pawcontrol/entity_factory.py†L805-L834】【cea389†L1-L9】

## Verbesserungsplan
1. **Vendor-Pfad beobachten.** Bei kommenden Home-Assistant-Releases prüfen, ob der echte `annotatedyaml` Build verfügbar ist und das Fallback nachgelagert aufräumen.【F:annotatedyaml/__init__.py†L28-L74】
2. **Fixture-Watcher pflegen.** Neue Companion-, Voice- oder Supervisor-Hilfsfixtures beobachten und den Guard bei Bedarf um zusätzliche Prüfungen erweitern – insbesondere falls künftige `hassfest`-Versionen weitere Loader-Ketten wie Companion-Proxys für neue Clients einführen.【F:tests/unit/test_fixture_usage_guard.py†L9-L120】【F:tests/unit/test_fixture_usage_guard.py†L2363-L2634】
3. **Wrapper-Erkennung weiterdenken.** Beobachte kombinierte Ressourcenpfade wie `Path.parents[1].with_segments(...).open_text()` oder `parents[0].resolve().joinpath(...)` sowie weitere `exec_module`-Callbacks, die Module via `setitem`/`setdefault` nachträglich mutieren, damit keine neuen Alias-Formen durchrutschen.【F:tests/unit/test_fixture_usage_guard.py†L441-L512】【F:tests/unit/test_fixture_usage_guard.py†L2841-L2904】【F:tests/unit/test_fixture_usage_guard.py†L2543-L2577】
4. **Vollinstallation validieren.** Nach Home-Assistant-Releases erneut `mypy` und `hassfest` gegen eine echte Laufzeit fahren, sobald die Upstream-Pakete aktualisiert sind, damit die in `pyproject.toml` hinterlegten Strictness-Gates auch außerhalb der Stub-Umgebung eingehalten bleiben.【F:pyproject.toml†L37-L72】
5. **Übersetzungsabdeckung ausweiten.** Prüfe mittelfristig, ob neben den Setup-Flags weitere Schlüssel automatisch gespiegelt oder via JSON-Schema getestet werden sollten; derselbe Workflow kann zusätzliche Konsistenzprüfungen übernehmen, sobald neue Kategorien als kritisch gelten.【F:.github/workflows/ci.yml†L120-L156】【F:script/sync_localization_flags.py†L1-L158】
6. **Runtime-Guard-Monitoring.** Beobachte bei kommenden Benchmark-Anpassungen, ob die Hybrid-Strategie aus Grobschlaf und Feintuning weitere Optimierung braucht oder optional per Feature-Flag deaktiviert werden muss, falls Plattformen ohne Hochfrequenz-Timer auftauchen.【F:custom_components/pawcontrol/entity_factory.py†L796-L818】

## Monitoring & Rhythmus
- Durchlaufe monatlich die Aufgaben aus `docs/MAINTENANCE.md`, damit Lokalisierungen, Diagnostik und Qualitätsnachweise aktuell bleiben.【F:docs/MAINTENANCE.md†L1-L40】
- Aktualisiere nach Feature-Änderungen die Contributor-Guides per `python -m script.sync_contributor_guides`, damit alle Assistenten dieselben Richtlinien ausliefern.【F:script/sync_contributor_guides.py†L1-L92】
